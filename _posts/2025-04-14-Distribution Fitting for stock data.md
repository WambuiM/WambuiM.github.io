---
title: Distribution fitting on stock data
categories: [ Distributions fitting]
tags: [ Distributions, Distributions fitting, stocks
] 
image: /images/image.png
---

# Distribution fitting on stock data.

In statistics, a distribution is the mathematical description of how the values of a variable are spread or dispersed. It shows the possible values a variable can take and how often (or with what probability) each value occurs.

**Types of distributions**

**Probability Distribution:** Applies to random variables, Describes the likelihood of each possible outcome. Can be discrete or continuous.

**Discrete Distributions:** Used when the variable can take countable values.

**Continuous Distributions:** Used when the variable can take any value within a range.

**Key Features of a Distribution**

Mean *(μ)*: Average value

Variance *(σ²)*: Spread of the data

Skewness: Asymmetry of the distribution

Kurtosis: "Peakedness" or tail heaviness

### Distribution fitting

Distribution fitting is the procedure of selecting a statistical
distribution that best fits to a data set generated by some
random process. In other words, if you have some random
data available, and would like to know what particular
distribution can be used to describe your data, then
distribution fitting is what you are looking for.

### Importance of selecting the best distribution fitting 


Probability distributions are essential tools for managing uncertainty. They allow you to perform precise calculations that support informed, data-driven business decisions. However, using the wrong distribution—one that doesn't accurately represent your data—can lead to incorrect results and, ultimately, poor decisions.

In many industries, the consequences of using an inappropriate statistical model can be severe. This might include delays in completing projects, costly design errors, or damage to expensive equipment. In fields like hydrology, selecting the right distribution is even more critical due to the potential impact on safety and infrastructure.

Distribution fitting is the process of identifying the most suitable probability distribution for your data. By doing so, you can build accurate models of the random processes you encounter, reducing the risk of errors and financial loss. Ultimately, this improves the quality of your analysis and supports better strategic decision-making.

### Which distribution to choose

To fit the selected "candidate" distributions to your data, you need to use statistical methods that estimate the parameters of each distribution based on your sample. This process typically involves specialized algorithms available in statistical software.

Once the distributions are fitted, the next step is to assess how well they match your data. This can be done using goodness-of-fit tests or by visually comparing the empirical distribution (derived from your data) with the theoretical distribution (based on the fitted model). These evaluations help you identify the distribution that best represents your data and serves as the most valid model for further analysis.

Lets delve into a practical example of fitting distribution to stock data in python.

```python
# IMPORT PACKAGES
import pandas as pd
import numpy as np
import datetime as dt
import matplotlib.pyplot as plt
import time
import math
import datetime
from scipy import stats
# Import curve fitting package from scipy
from scipy.optimize import curve_fit
import warnings
warnings.filterwarnings("ignore")
ksN = 100           # Kolmogorov-Smirnov KS test for goodness of fit: samples
ALPHA = 0.02        # significance level for hypothesis test
```
Data importation and cleaning
```python
Market_P = pd.read_excel('Market_Prices.xlsx')
```
```python
Safaricom = Market_P[Market_P['Stock Name'] == 'Safaricom Ltd Ord 0.05'].iloc[:, 1:5].set_index("MarketDate")
Safaricom.head(5)
```
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>MarketPrice</th>
      <th>High</th>
      <th>Low</th>
    </tr>
    <tr>
      <th>MarketDate</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2019-01-02</th>
      <td>22.250</td>
      <td>23.000</td>
      <td>22.200</td>
    </tr>
    <tr>
      <th>2019-01-03</th>
      <td>22.150</td>
      <td>22.500</td>
      <td>21.800</td>
    </tr>
    <tr>
      <th>2019-01-04</th>
      <td>21.300</td>
      <td>22.000</td>
      <td>21.000</td>
    </tr>
    <tr>
      <th>2019-01-07</th>
      <td>21.450</td>
      <td>21.800</td>
      <td>21.300</td>
    </tr>
    <tr>
      <th>2019-01-08</th>
      <td>22.000</td>
      <td>22.200</td>
      <td>21.500</td>
    </tr>
  </tbody>
</table>
</div>

```python
idx = pd.date_range(Market_P['MarketDate'].min(), Market_P['MarketDate'].max())
# Fill Missing Dates for Safaricom 
#Add month and year
Saf = Safaricom.reindex(idx, method='ffill').rename_axis('MarketDate').reset_index()
Saf['Year'] = pd.DatetimeIndex(Saf["MarketDate"]).year
Saf['Month'] = pd.DatetimeIndex(Saf["MarketDate"]).month
saf_df2024 = Saf[Saf["Year"] >= 2024]
```

Visualize the data
```python
import matplotlib.pyplot as plt

# Ensure Date column is in datetime format and sorted
saf_df2024

# Plot
plt.figure(figsize=(12, 6))
plt.plot(saf_df2024['MarketDate'], saf_df2024['MarketPrice'], label='Safaricom', color='blue')
plt.title("Safaricom Daily Market Price Over Time", fontsize=16)
plt.xlabel("Date")
plt.ylabel("Market Price")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()
```
![](trendline.png)


Next, we create a list of approximately 60 SciPy distributions that we want to use with the fitter, and import them accordingly.

```python
#Load Possible distributions
from scipy.stats import (
    norm, beta, expon, gamma, genextreme, logistic, lognorm, triang, uniform, fatiguelife,            
    gengamma, gennorm, dweibull, dgamma, gumbel_r, powernorm, rayleigh, weibull_max, weibull_min, 
    laplace, alpha, genexpon, bradford, betaprime, burr, fisk, genpareto, hypsecant, 
    halfnorm, halflogistic, invgauss, invgamma, levy, loglaplace, loggamma, maxwell, 
    mielke, ncx2, ncf, nct, nakagami, pareto, lomax, powerlognorm, powerlaw, rice, 
    semicircular,trapz, trapz, invweibull, foldnorm, foldcauchy, cosine, exponpow, 
    exponweib, wald, wrapcauchy, truncexpon, truncnorm, t, rdist
    )


distributions = [
    norm, beta, expon, gamma, genextreme, logistic, lognorm, triang, uniform, fatiguelife,            
    gengamma, gennorm, dweibull, dgamma, gumbel_r, powernorm, rayleigh, weibull_max, weibull_min, 
    laplace, alpha, genexpon, bradford, betaprime, burr, fisk, genpareto, hypsecant, 
    halfnorm, halflogistic, invgauss, invgamma, levy, loglaplace, loggamma, maxwell, 
    mielke, ncx2, ncf, nct, nakagami, pareto, lomax, powerlognorm, powerlaw, rice, 
    semicircular, trapz, invweibull, foldnorm, foldcauchy, cosine, exponpow, 
    exponweib, wald, wrapcauchy, truncexpon, truncnorm, t, rdist
    ]
```
```python
saf_df2024['MarketDate']
saf_df2024
```
A Ks test function to checks the goodness of fit of all the distributions fit
The function takes data, distribution name and number of parameters.

```python
# KS test for goodness of fit
def kstest(data, distname, paramtup):
    ks = stats.kstest(data, distname, paramtup, ksN)[1]   # return p-value
    return ks             # return p-value
```

A function to fit all the distributions specified above
Takes in data to be fitted and distributions
Returns distribution name, ks p-value, parameters

```python
# Fit distributions specified
def fitdist(data, dist):    
    fitted = dist.fit(data, floc=0.0)
    ks = kstest(data, dist.name, fitted)
    res = (dist.name, ks, *fitted)
    return res
```

A function to fit distributions using the above function and convert tuples to a dataframe
```python
#Fit distributions and convert data to a more readable format
def fitAllDist(data):
    # call fitting function for all distributions in list
    res = [fitdist(data,D) for D in distributions]
    
    # convert the fitted list of tuples to dataframe
    pd.options.display.float_format = '{:,.3f}'.format
    df = pd.DataFrame(res, columns=["distribution", "KS p-value", "param1", "param2", "param3", "param4", "param5"])
    df["distobj"] = distributions
    df.sort_values(by=["KS p-value"], inplace=True, ascending=False)
    df.reset_index(inplace=True)
    df.drop("index", axis=1, inplace=True)
    return df.head(9)
```
```python
fitAllDist(saf_df2024)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>distribution</th>
      <th>KS p-value</th>
      <th>param1</th>
      <th>param2</th>
      <th>param3</th>
      <th>param4</th>
      <th>param5</th>
      <th>distobj</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>weibull_min</td>
      <td>0.002</td>
      <td>10.142</td>
      <td>0.000</td>
      <td>16.533</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>&lt;scipy.stats._continuous_distns.weibull_min_ge...</td>
    </tr>
    <tr>
      <th>1</th>
      <td>fisk</td>
      <td>0.001</td>
      <td>14.329</td>
      <td>0.000</td>
      <td>15.669</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>&lt;scipy.stats._continuous_distns.fisk_gen objec...</td>
    </tr>
    <tr>
      <th>2</th>
      <td>ncf</td>
      <td>0.001</td>
      <td>276.687</td>
      <td>360.068</td>
      <td>7.566</td>
      <td>0.000</td>
      <td>15.219</td>
      <td>&lt;scipy.stats._continuous_distns.ncf_gen object...</td>
    </tr>
    <tr>
      <th>3</th>
      <td>alpha</td>
      <td>0.001</td>
      <td>8.806</td>
      <td>0.000</td>
      <td>136.816</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>&lt;scipy.stats._continuous_distns.alpha_gen obje...</td>
    </tr>
    <tr>
      <th>4</th>
      <td>nct</td>
      <td>0.001</td>
      <td>48.604</td>
      <td>20.654</td>
      <td>0.000</td>
      <td>0.750</td>
      <td>NaN</td>
      <td>&lt;scipy.stats._continuous_distns.nct_gen object...</td>
    </tr>
    <tr>
      <th>5</th>
      <td>loggamma</td>
      <td>0.001</td>
      <td>12.800</td>
      <td>0.000</td>
      <td>6.270</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>&lt;scipy.stats._continuous_distns.loggamma_gen o...</td>
    </tr>
    <tr>
      <th>6</th>
      <td>exponweib</td>
      <td>0.001</td>
      <td>4.193</td>
      <td>5.003</td>
      <td>0.000</td>
      <td>13.866</td>
      <td>NaN</td>
      <td>&lt;scipy.stats._continuous_distns.exponweib_gen ...</td>
    </tr>
    <tr>
      <th>7</th>
      <td>betaprime</td>
      <td>0.001</td>
      <td>996.326</td>
      <td>84.802</td>
      <td>0.000</td>
      <td>1.324</td>
      <td>NaN</td>
      <td>&lt;scipy.stats._continuous_distns.betaprime_gen ...</td>
    </tr>
    <tr>
      <th>8</th>
      <td>invgamma</td>
      <td>0.001</td>
      <td>78.045</td>
      <td>0.000</td>
      <td>1,212.599</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>&lt;scipy.stats._continuous_distns.invgamma_gen o...</td>
    </tr>
  </tbody>
</table>
</div>

A function that plots distribution that has the highest p_value
Plots the first 9 distributions

```python
def plot_fitted_pdf(df, data):
    
    N = len(df)
    chrows = math.ceil(N/3)                    # how many rows of charts if 3 in a row
    fig, ax = plt.subplots(chrows, 3, figsize=(20, 5 * chrows))
    ax = ax.ravel()
    dfRV = pd.DataFrame()

    for i in df.index:

        # D_row = df.iloc[i,:-1]
        D_name = df.iloc[i,0]
        D = df.iloc[i,7]
        KSp = df.iloc[i,1]
        params = df.iloc[i,2:7]    
        params = [p for p in params if ~np.isnan(p)]

        # calibrate x-axis by finding the 1% and 99% quantiles in percent point function
        x = np.linspace(
                    D.ppf(0.01, *params), 
                    D.ppf(0.99, *params), 100)

        #fig, ax = plt.subplots(1, 1)
        # plot histogram of actual observations
        ax[i].hist(data, density=True, histtype='stepfilled', alpha=0.2)
        # plot fitted distribution
        rv = D(*params)
        title = f'pdf {D_name}, with p(KS): {KSp:.2f}' 
        ax[i].plot(x, rv.pdf(x), 'r-', lw=2, label=title)
        ax[i].legend(loc="upper right", frameon=False)
```


```python
# call the plotting function
plot_fitted_pdf(df_ks, saf_df2024)
pass
```

![](Distributions.png)
 
 
 Select distribution with the highest pvalue and its parameters
 
  ```python
# fitted distribution with highest p-value of KS test
D_opt = df_ks.loc[df_ks["KS p-value"].idxmax()]
# D_opt[:-1]
D_opt
```
distribution                                          weibull_min
KS p-value                                                  0.004
param1                                                     10.227
param2                                                      0.000
param3                                                     25.997
param4                                                        NaN
param5                                                        NaN
distobj         <scipy.stats._continuous_distns.weibull_min_ge...
Name: 0, dtype: object

Take the best fit distribution and explore its statistics further

```python
# script takes this best fitting distribution and begins to works with it:
# parameters

print(D_opt.iloc[0])            # name
DO = D_opt.iloc[7]              # distribution object

params = D_opt.iloc[2:7]    
params = [p for p in params if ~np.isnan(p)]
params
```
weibull_min

[10.227441700388379, 0.0, 25.99652543683319]

Statistic of the best fit distribution

```python
# statistics of the best fitting distribution
stats = DO.stats(*params, "mvsk")
stat_names = ["mean", "variance", "skew", "kurtosis"]
dict_stats = {k:v for k,v in zip(stat_names, stats)} 
_ = [print(k,":",f'{v:.4f}') for k,v in dict_stats.items()]
```




**Summary**

The Distribution Fitter in Python is a tool used to identify the probability distribution that best fits a given dataset. It simplifies the process of distribution fitting by testing a wide range of distributions—typically from the SciPy library—against your data. The fitter library automates this by allowing users to input a one-dimensional array of numerical values, fit multiple candidate distributions, and compare their goodness of fit using statistical metrics. With just a few lines of code, it generates a summary of the best-matching distributions, helping users make data-driven choices for modeling, simulation, or statistical analysis. This is especially useful in fields like finance, engineering, and scientific research where selecting the correct distribution is crucial for accurate results.